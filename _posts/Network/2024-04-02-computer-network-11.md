---
bigtitle: "제2장 애플리케이션 계층"
title: "2.4 DNS: 인터넷의 디렉터리 서비스"
excerpt: "2.4 DNS: 인터넷의 디렉터리 서비스"
categories: ['Computer Network']
tags:
  - computer
  - network

toc: true
toc_sticky: true
use_math: true
 
date: 2024-04-01
last_modified_at: 2024-04-01
---
&nbsp;&nbsp;인터넷 호스트를 구별하기 위해 사용하는 식별자에는 **호스트 이름**(hostname)과 **IP 주소**(IP address)가 있다. 

* **호스트 이름**(hostname)
  * www.facebook.com, www.google.com ...
  * 호스트 이름은 알파뉴메릭 문자로 구성되므로 라우터가 처리하는 데 어려움이 있으므로 IP 주소로 식별한다.

* **IP 주소**(IP address)
  * 121.7.106.83과 같은 형태
  * 0~255의 십진수로 표현하는 각 바이트는 점으로 구분
  * 왼쪽에서 오른쪽으로 읽어 호스트의 위치 정보를 얻음

## 1. DNS가 제공하는 서비스

### DNS(domain name system)
* 호스트 이름을 IP 주소로 변환해주는 디렉터리 서비스
* DNS 서버들의 계층구조로 구현된 분산 데이터베이스
* 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜
* DNS 프로토콜은 UDP상에서 수행되고 포트 번호 53을 이용


### DNS 작동 순서

1. 사용자 컴퓨터는 DNS 애플리케이션의 클라이언트 역할을 담당한다.
2. 브라우저는 URL로부터 호스트 이름 www.google.com을 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트 측에 넘긴다.
3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의를 보낸다.
4. DNS 클라이언트는 호스트 이름에 대한 IP 주소를 포함한 응답을 받는다.
5. 브라우저가 DNS로부터 IP 주소를 받으면, 브라우저는 해당 IP 주소와 그 주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화한다.


### DNS가 제공하는 추가 서비스


#### 호스트 에일리어싱(host aliasing)

&nbsp;&nbsp;호스트는 하나 이상의 별명(호스트 이름)을 가질 수 있다. 예를 들어 relay1.west-coast.enterprise.com과 같은 호스트 이름은 enterprise.com과 www.enterprise.com과 같은 2개의 별칭을 얻을 수 있다. 이때 relay1.west-coast.enterprise.com은 **정식 호스트 이름**(canonical hostname)이라고 한다.


#### 메일 서버 에일리어싱(mail server aliasing)

&nbsp;&nbsp;핫메일 서버의 호스트 이름은 복잡하여 사용자가 기억하기 힘들다. DNS는 호스트의 별칭 호스트 이름에 대한 정식 호스트 이름을 얻도록 메일 애플리케이션에 의해 수행한다.



#### 부하 분산(load distribution)

&nbsp;&nbsp;naver.com과 같이 인기 있는 사이트의 부하를 분산하기 위한 서비스이다.
<br/>

**인기 있는 사이트는 여러 서버에 중복되어 있어서, 각 서버가 다른 종단 시스템에서 수행되고 다른 IP 주소를 갖는다.**

이때 여러 IP 주소가 하나의 정식 호스트 이름과 연관되어 있다. DNS 데이터베이스는 이 IP 주소 집합을 갖고 있다.

**클라이언트가 주소 집합으로 매핑하는 호스트 이름에 대한 DNS 질의를 하면, 서버는 IP 주소 집합 전체를 가지고 응답한다.**

<br/>

**각 응답에서의 주소는 순환식으로 보낸다.**

클라이언트는 대체로 주소 집합 내부의 첫 번째 IP 주소로 HTTP 요청 메시지를 보내므로, **DNS의 순환 방식은 트래픽을 분산하는 효과를 낸다.**

<br/>

[[참고] What is DNS Load Balancing?](https://www.nginx.com/resources/glossary/dns-load-balancing/)

<br/>
<br/>
<br/>

사용자의 호스트에서 실행되는 어떤 애플리케이션이 호스트 이름을 IP 주소로 변환하려 한다고 가정하자.

과정은 다음과 같다.

1. 애플리케이션이 호스트 이름을 명시하여 DNS 클라이언트 호출한다.


2. 사용자 호스트의 DNS는 네트워크에 질의 메시지를 보낸다.  
   이때 모든 질의와 응답 메시지는 `포트 53의 UDP 데이터그램`으로 보내진다.


3. 응답 메시지를 애플리케이션에 전달한다.

<br/>

DNS는 간단해보이지만 매우 복잡한데, 이는 전 세계에 분산된 많은 DNS 서버 뿐만 아니라  
DNS 서버와 질의를 하는 호스트 사이에서 어떻게 통신하는지를 명시하는 애플리케이션 계층 프로토콜로 구성되어 있다.

<br/>
<br/>

## DNS가 중앙 집중 데이터베이스라면?

> why not centralize DNS?

만약 DNS가 간단한 설계로 모든 매핑을 포함하는 하나의 인터넷 네임 서버를 갖고 있다면, 수많은 호스트를 가진 오늘날 다음과 같은 문제를 일으킬 수 있다.

- 서버의 고장 : 이 네임 서버가 고장 나면, 전체 인터넷이 작동하지 않는다. (`single point of failure`)
- 트래픽 양의 과부하 : 단일 DNS 서버가 모든 질의를 해결해야 한다.
- 먼 거리의 중앙 집중 데이터베이스: 단일 DNS 서버가 모든 질의 클라이언트로부터 '가까울' 수만은 없다. 즉, 멀면 멀수록 모든 질의가 느려진다.
- 유지 관리
    - 단일 네임 서버는 모든 인터넷 호스트에 대한 레코드를 유지해야 한다.
    - 모든 새로운 호스트를 반영하기 위해 자주 갱신되어야 하고, 사용자에게 호스트를 등록할 수 있도록 허용하는 것과 관련된 인증 문제가 있다.

<br/>

요약하면 중앙 집중 데이터베이스는 **확장성(scalability)이 전혀 없고**, 결과적으로 DNS는 분산되도록 설계되어있다.

<br/>
<br/>

## 분산(distributed) 계층(hierarchical) 데이터 베이스

![image](https://user-images.githubusercontent.com/76640167/210617280-e684c1b7-4f6c-4224-af7e-2e88334bdea2.png){: .align-center}

<br/>
<br/>

DNS는 많은 서버를 이용하고 이들을 계층 형태로 구성하며 전세계에 분산시킨다.

<br/>

### 계층 DNS 서버의 종류

#### 루트(root) DNS 서버

- 1000개 이상의 루트 서버 인스턴스가 세계에 흩어져 있다.
- 루트 네임 서버는 TLD 서버의 IP 주소들을 제공한다.
- `인터넷 할당 번호 관리기관 ICANN(Internet Corporation for Assigned Names and Numbers)`에 의해 조정된다.

<br/>

#### TLD(최상위 레벨 도메인) DNS 서버

- Top-Level Domain, TLD
- `com`, `org`, `net` 같은 상위 레벨 도메인과 `kr`, `uk` 같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버가 있다.
- Authoritative(책임) DNS 서버에 대한 IP 주소를 제공한다.

<br/>

#### Authoritative(책임) DNS 서버

- 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다.
    - 기관의 책임 DNS 서버는 이 DNS 레코드를 갖고 있다.
- 기관은 직접 자신의 책임 DNS 서버의 구현을 선택할 수 있고, 일부 서비스 제공자의 책임 DNS 서버에 이 레코드를 저장하도록 비용을 지불한다.

<br/>

#### 로컬(local) DNS 서버

- 로컬 DNS 서버는 서버들의 계층 구조에 엄격하게 속하지는 않지만 DNS 구조의 중심에 있다.
- ISP는 로컬 DNS 서버를 갖고, 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공한다.
- 대체로 호스트에 가까이 있기 때문에 지연이 적다.

<br/>
<br/>

### 예시

![image](https://user-images.githubusercontent.com/76640167/210620114-71bda09c-0995-410a-b8e1-70ee1c5b76bd.png){: .align-center}

<br/>
<br/>

위 그림에서 `cse.nyu.edu`가 `gaia.cs.umass.edu`의 IP 주소를 원한다고 가정해보자.

1. 자신의 로컬 DNS 서버에 질의를 보낸다. 이때 변환하고 싶은 호스트의 이름을 같이 보낸다.
2. 로컬 DNS 서버는 그 질의 메시지를 루트 DNS 서버에게 전달한다.
3. 루트 DNS 서버는 `edu`를 인식하고, `edu`에 대한 책임을 가진 TLD 서버의 IP 주소 목록을 로컬 DNS 서버에 보낸다.
4. 로컬 DNS 서버는 TLD 서버에 질의를 보낸다.
5. TLD 서버는 `umass.edu`를 인식하고, `dns.umass.edu`로 이름 지어진 책임 DNS 서버의 IP 주소로 응답한다.
6. 로컬 DNS 서버는 직접 책임 DNS 서버로 질의 메시지를 다시 보낸다.
7. 최종 `gaia.cs.umass.edu`의 IP 주소를 응답한다.
8. 호스트에 최종 IP 주소를 응답한다.

<br/>

여기서는 총 8번의 DNS 메시지가 보내졌다.

일반적으로 TLD 서버는 위의 예시와 같이 책임 DNS 서버를 알지 않고, 책임 DNS 서버를 아는 중간 DNS 서버를 알고 있다.

즉, 해당 질의 과정 까지 포함되면 전체 10번의 메시지를 보내게 된다.

<br/>

위 예는 `재귀적 질의`와 `반복적 질의`를 사용한다.

`cse.nyu.edu`로부터 `dns.nyu.edu`로 보내는 질의는 자신을 필요한 매핑을 대신하여 얻도록 `dns.nyu.edu`에 요구하므로 재귀적 질의이고,  
나머지는 반복적 질의다.

<br/>
<br/>

아래 그림은 모든 질의가 재귀적인 DNS 질의 사슬을 보여준다.

![image](https://user-images.githubusercontent.com/76640167/210622856-0c967585-6ce3-45c7-97bd-c1ed6e3143fc.png){: .align-center}

<br/>
<br/>

> 일반 질의는 전형적으로 반복적 질의를 따른다.

- 재귀적 질의에서는 높은 계층에 있는 DNS server가 책임져야 하는 것들이 많다.
    - puts burden of name resolutions on contacted name server
    - heavy load at upper levels of hierarchy
- 중요한 infra를 지키는 것이 훨씬 낫기 때문에, 중요한 root name server 보단 default name server가 일을 더 하는 것이 좋다.

<br/>
<br/>

## DNS 캐싱

실제로는 DNS 지연 성능 향상과 네트워크의 DNS 메시지 수를 줄이기 위해 `캐싱(caching)`을 사용한다.

> 질의 사슬에서 **DNS 서버는 DNS 응답을 받았을 때 로컬 메모리에 응답에 대한 정보를 저장할 수 있다.**

<br/>

만약 호스트의 이름과 IP 주소 쌍이 DNS 서버에 저장되고 다른 호스트 이름으로부터 같은 질의가 DNS 서버로 도착한다면,  
DNS 서버는 호스트 이름에 대한 책임이 없을 때조차 원하는 주소를 제공할 수 있다.

호스트 DNS와 IP 사이의 매핑과 호스트는 영구적이지 않기 때문에 어떤 기간(`TTL, Time to Live`) 이후에 저장된 정보를 제거한다.

로컬 DNS 서버는 구체적인 IP 주소 이외에도 TLD 서버의 IP를 저장하여 루트 DNS 서버를 우회할 수 있게 한다.

<br/>
<br/>
<br/>

# 2.4.3 DNS 레코드와 메시지

각 DNS는 **하나 이상의 자원 레코드를 가진** 메시지로 응답한다.

<br/>

## DNS 자원 레코드

DNS 서버들은 호스트 이름을 IP 주소로 매핑하기 위한 `자원 레코드(Resource Records)`를 저장한다.

자원 레코드는 다음과 같은 필드를 포함하는 4개의 Tuple로 되어 있다.

```
(Name, Value, Type, TTL)
```

`TTL(Time to Live)`은 자원 레코드의 생존 기간이다.

Name과 Value는 Type을 따른다. 즉, **Type에 따라서** Name과 Value에 대한 semantic(해석법)이 달라진다.

<br/>

### Type = `A`

> **A**ddress  
> Type A 레코드는 표준 호스트 이름의 IP 주소 매핑을 제공한다.

- Name : 호스트 이름(hostname)
- Value : 호스트 이름에 대한 IP 주소

<br/>

### Type = `NS`

> **N**ame **S**erver

- Name : 도메인(domain)
- Value : 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 이름

<br/>

### Type = `CNAME`

> **C**anonical **NAME**

- Name : 정식 호스트 이름의 alias name
- Value : 별칭 호스트 이름 Name에 대한 정식 호스트 이름

<br/>

### Type = `MX`

> **M**ail e**X**change

- Value : 별칭 호스트 이름 Name을 갖는 메일 서버의 정식 이름
- MX 레코드는 메일 서버의 호스트 이름이 간단한 별칭을 갖는 것을 허용한다.

<br/>

메일 서버의 정식 이름을 얻기 위해서는 MX 레코드에 대한 질의를 해야 하고, 다른 서버의 정식 이름을 얻기 위해선 CNAME 레코드에 대한 질의를 한다.

<br/>

DNS 서버가 특별한 호스트 이름에 대한 책임 서버이면, 그 DNS 서버는 호스트 이름에 대한 Type A 레코드를 포함한다.

서버가 호스트 이름에 대한 책임 서버가 아니라면, 그 서버는 호스트 이름을 포함하는 DNS 서버의 IP 주소를 제공하는 Type A 레코드도 포함할 것이다.

<br/>
<br/>
<br/>

## DNS 메시지

DNS의 요청과 응답 메시지는 모두 아래 그림과 같은 포맷을 갖고 있다.

![image](https://user-images.githubusercontent.com/76640167/210725479-3cc2dfe9-5ffd-49f8-9385-5cc244b7c2e6.png){: .align-center}

<br/>
<br/>

### header

`처음 12 byte의 헤더 영역` : 여러 필드를 갖고 있다.

- 첫 필드는 질의를 식별하는 16 bit의 숫자이다.  
  이 식별자는 질의에 대한 응답 메시지에 복사되어, 클라이언트가 보낸 질의와 수신된 응답 간의 일치를 식별하게 한다.


- `플래그(flag) 필드`에는 여러 개의 플래그가 있다.
    - 1 비트의 `질의/응답 플래그`는 메시지가 질의인지 응답인지 구분하게 한다.
    - 1 비트의 `책임 플래그`는 DNS 서버가 질의 이름에 대해 책임 서버일 때 응답 메시지에 설정된다.
    - 1 비트의 `재귀 요구 플래그`는 DNS 서버가 레코드를 갖지 않을 때 재귀적 질의를 수행하기를 클라이언트가 원할 때 설정된다.
    - 1 비트로 된 `재귀 가능 필드`는 DNS 서버가 재귀 질의를 지원하면 응답에 설정된다.


- 나머지 4개의 `'개수' 필드`는 헤더 다음에 오는 데이터 영역의 네 가지 타입의 발생 횟수를 나타낸다.

### payload

- `질문 영역`
    - 현재 질의에 대한 정보를 포함한다.
    - 질의되는 이름을 포함하는 이름 필드와, 이름에 대해 문의되는 질문 타임을 나타내는 타입 필드를 나타낸다. (A, NS 등)
- `답변 영역`
    - 원래 질의된 이름에 대한 자원 레코드를 포함한다. (value, TTL)
    - **여러 개의 자원 레코드를 보낼 수 있는데, 하나의 호스트 이름이 여러 개의 IP를 가질 수 있기 때문이다. (중복 웹 서버)**
- `책임 영역`
    - 다른 책임 서버의 레코드를 포함한다.
- `추가 영역`
    - 다른 도움이 되는 레코드를 갖고 있다.
    - 예를 들어, MX 질의에 대한 응답에서 응답 필드는 전자메일 서버의 정식 호스트 이름을 제공하는 자원 레코드를 갖고 있고,  
      추가 영역은 정식 호스트 이름에 대한 IP 주소를 제공하는 A 레코드를 포함한다.

<br/>
<br/>

## DNS 데이터베이스에 레코드 삽입

도메인 네임 `networkutopia.com`을 `등록 기관(DNS registrar)`에 등록한다고 가정해보자.

> `등록 기관(DNS registrar)`은 도메인 네임의 유일성을 확인하고,  
> 그 도메인 네임을 DNS 데이터베이스에 넣고, 그 서비스에 대한 요금을 받는 상업 기관이다.

이전에는 작은 등록기관이 독점했었지만, 이제는 많은 기관이 경쟁하고 ICANN이 이러한 여러 등록기관을 승인해준다.

<br/>

도메인 네임을 어떤 등록기관에 등록할 때 등록 기관에 주책임 서버와 부책임 서버의 이름과 IP 주소를 등록기관에 제공해야 한다.

- 주책임 서버 : `dns1.networkutopia.com` / 주책임 서버 IP : 212.2.212.1
- 부책임 서버 : `dns2.networkutopia.com` / 부책임 서버 IP : 212.2.212.2

위와 같다고 가정하자.

<br/>

이 두 책임 DNS 서버 각각에 대해 등록 기관은 `Type NS`와 `Type A` 레코드가 **TLD com 서버에 등록되도록 확인한다.**

특히 주책임 서버의 경우 다음 두 개의 자원 레코드를 DNS 서버에 삽입한다.

```
(networkutopia.com, dns1.networkutopia.com, NS)
(dns1.networkutopia.com, 212.212.212.1, A)
```

<br/>

또한, `Type A` 레코드와 메일 서버에 대한 `Type MX` 자원 레코드가 **책임 DNS 서버에 등록되는 것을 확인한다.**

이러한 모든 단계가 끝나면 여러 사람들이 웹 사이트를 방문할 수 있고, 전자메일을 보낼 수 있게 된다.

<br/>
<br/>

## DNS 취약점

### DDoS 대역폭 플러딩 공격

공격자는 DNS 루트 서버로 다량의 패킷을 보내려는 시도를 하여 다른 DNS 질의들이 응답을 받지 못하게 하려 한다.

실제로 이 일이 일어났지만, 많은 DNS 루트 서버들은 루트 서버로 향하는 공격자가 사용한 ICMP 핑 메시지를 블록하도록 형상화한 패킷 필터로 보호되었고,  
대부분의 로컬 DNS 서버가 최상위 도메인 서버들의 IP 주소들을 캐싱하고 있어서 피해가 거의 없었다.

<br/>

즉, 더 효과적인 공격은 최상위 도메인 서버를 공격하는 것이고, 실제로 최상위 도메인 서비스 제공자 Dyn에 이러한 일이 발생했다.

이는 유명 애플리케이션들이 무차별 교란되는 결과를 야기했다.

<br/>

### DNS 중독 공격

공격자는 DNS 서버로 가짜 응답을 보내어 그 서버가 자신의 캐시에 가짜 레코드를 받아들이도록 속임수를 쓴다.

이러한 공격은 웹 사용자들을 공격자의 웹사이트로 유도하는 데 이용될 수 있다.

이러한 공격을 막기 위해 DNS 보안 확장 프로토콜이 개발되어 사용되고 있다.

##### www
* 월드 와이드 웹(World Wide Web, WWW, W3)
* 세계적인 인터넷 망, 인터넷이 전세계적으로 거미줄처럼 엮어져 있는 것을 나타냄