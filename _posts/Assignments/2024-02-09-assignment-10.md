---
title: "소켓 프로그래밍 2"
categories: Assignment
toc: true
toc_sticky: true
---
`client.py`

```py
import socket

def connect_to_server(server_address, server_port):
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((server_address, server_port))
    return client_socket

def client_program():
    server_address = socket.gethostname()
    server_port = 9999
    client_socket = connect_to_server(server_address, server_port)

    while True:
        address = input("주소를 입력하세요(종료하려면 exit 입력): ")

        client_socket.send(address.encode())

        if address.lower() == 'exit':
            print("프로그램을 종료한다.")
            break

        result = client_socket.recv(1024).decode()

        if result.startswith("Error:"):
            print("에러 발생")
        else:
            print(f"{address}의 IP 주소: {result}")

    client_socket.close()

if __name__ == "__main__":
    client_program()
```
이 코드는 클라이언트 프로그램으로, 서버에 연결하여 도메인 주소를 전송하고 해당 도메인의 IP 주소를 받아와 출력하는 역할을 한다. 주요 부분은 다음과 같다:

### 함수 설명

1. **`connect_to_server` 함수**
   - `server_address`와 `server_port`를 인자로 받아 서버에 연결한다.
   - `socket` 객체를 생성하고, 서버에 연결한 후 소켓 객체를 반환한다.

2. **`client_program` 함수**
   - `server_address`와 `server_port`를 설정한다.
   - `connect_to_server` 함수를 호출하여 서버에 연결하고 소켓 객체를 받는다.
   - 무한 루프를 통해 사용자로부터 도메인 주소를 입력받고, 이를 서버에 전송한다.
   - 서버로부터 받은 결과를 디코딩하여 출력한다.
   - 사용자가 "exit"를 입력하면 루프를 종료하고 소켓을 닫는다.

### 코드 흐름

1. 클라이언트가 실행되면 서버에 연결한다.
2. 사용자는 도메인 주소를 입력한다.
3. 입력한 주소가 서버로 전송된다.
4. 서버는 입력한 주소에 대한 IP 주소를 반환한다.
5. 클라이언트는 반환된 IP 주소를 출력한다.
6. 사용자가 "exit"를 입력하면 프로그램이 종료된다.

<br>

`localDNS.py`

```py
import socket
import oracledb

def connectDB():
    dsn = "localhost/dnspdb"
    user = "testdns"
    pw = "1234"

    conn = oracledb.connect(user = user, password = pw, dsn = dsn)
    return (conn)

def disconnectDB(conn):
    conn.close()

def connect_to_upper_server(address, server_address, server_port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as local_socket:
        local_socket.connect((server_address, server_port))
        local_socket.send(address.encode())
        result = local_socket.recv(1024).decode()
        return result

def find_address(address):
    sql = "SELECT ip\
           FROM local_dns\
           WHERE domain = :var1"
    
    conn = connectDB()
    curs = conn.cursor()

    try:
        curs.execute(sql, var1 = address)
        result = curs.fetchone()    

        if result:
            return result[0]
        else:
            server_address = socket.gethostname()
            server_port = 9998
            result = connect_to_upper_server(address, server_address, server_port)
            
            if not result.startswith("Error:"):
                sql_insert = "INSERT INTO local_dns (domain, ip) VALUES (:domain, :ip)"
                curs.execute(sql_insert, domain = address, ip = result)
                conn.commit()
            return result
    
    except Exception as e:
        print(f"오류 발생: {e}")
        return None

    finally:
        curs.close()
        disconnectDB(conn)
        
def handle_client(client_socket, client_address):
    print(f"클라이언트 {client_address}가 연결 됨...")
    with client_socket:
        while True:
            data = client_socket.recv(1024).decode()
            if not data or data.lower() == 'exit':
                break
            print(f"수신한 데이터: {data}")
            result = find_address(data)
            client_socket.send(result.encode())
    print(f"클라이언트 {client_address}가 연결을 종료함.")

def server_program():
    host = socket.gethostname()
    port = 9999

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((host, port))
        server_socket.listen()
        print(f"서버가 {host}:{port}에서 클라이언트 연결 대기 중...")

        while True:
            client_socket, client_address = server_socket.accept()
            handle_client(client_socket, client_address)

if __name__ == "__main__":
    server_program()
```
이 코드는 DNS 서버 프로그램으로, 클라이언트가 도메인 주소를 전송하면 해당 도메인의 IP 주소를 데이터베이스에서 조회하거나 상위 서버에서 가져와 클라이언트에게 반환하는 기능을 한다. 주요 부분은 다음과 같다:

### 데이터베이스 연결 함수
- `connectDB`: 데이터베이스에 연결하고 연결 객체를 반환한다.
- `disconnectDB`: 데이터베이스 연결을 닫다.

### 상위 서버 연결 함수
- `connect_to_upper_server`: 상위 DNS 서버에 연결하여 도메인 주소의 IP 주소를 요청하고 결과를 반환한다.

### 주소 찾기 함수
- `find_address`: 데이터베이스에서 도메인 주소의 IP 주소를 조회한다. 조회 결과가 없으면 상위 서버에서 IP 주소를 가져와 데이터베이스에 저장한다.

### 클라이언트 처리 함수
- `handle_client`: 클라이언트의 요청을 처리하고 결과를 클라이언트에게 반환한다.

### 서버 프로그램 함수
- `server_program`: 서버 소켓을 생성하고 클라이언트의 연결을 대기하며, 클라이언트가 연결되면 `handle_client` 함수를 호출하여 처리한다.

### 요약
1. 서버는 클라이언트로부터 도메인 주소를 수신한다.
2. 데이터베이스에서 도메인 주소에 대한 IP 주소를 조회한다.
3. IP 주소가 없으면 상위 DNS 서버에 요청하여 IP 주소를 가져온다.
4. 가져온 IP 주소를 데이터베이스에 저장한다.
5. 클라이언트에게 IP 주소를 반환한다.

<br>

`upperDNS.py`

```py
import socket
import oracledb

def connectDB():
    dsn = "localhost/dnspdb"
    user = "testdns"
    pw = "1234"

    conn = oracledb.connect(user = user, password = pw, dsn = dsn)
    return (conn)

def disconnectDB(conn):
    conn.close()

def find_address(address):
    sql = "SELECT ip\
           FROM upper_dns\
           WHERE domain = :var1"
    
    conn = connectDB()
    curs = conn.cursor()
    curs.execute(sql, var1 = address)

    result = curs.fetchone()

    curs.close()
    disconnectDB(conn)

    if result:
        return result[0]
    else:
        return "Error: 상위 DNS 서버에도 존재하지 않음"
    
def handle_client(client_socket, client_address):
    print(f"클라이언트 {client_address}가 연결 됨...")
    with client_socket:
        while True:
            data = client_socket.recv(1024).decode()
            if not data or data.lower() == 'exit':
                break
            print(f"수신한 데이터: {data}")
            result = find_address(data)
            client_socket.send(result.encode())
    print(f"클라이언트 {client_address}가 연결을 종료함.")

def server_program():
    host = socket.gethostname()
    port = 9998

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind((host, port))
        server_socket.listen()
        print(f"서버가 {host}:{port}에서 클라이언트 연결 대기 중...")

        while True:
            client_socket, client_address = server_socket.accept()
            handle_client(client_socket, client_address)

if __name__ == "__main__":
    server_program()
```
이 코드는 상위 DNS 서버 역할을 하는 프로그램이다. 클라이언트가 도메인 주소를 요청하면 데이터베이스에서 해당 도메인의 IP 주소를 조회하여 반환한다. 주요 부분을 간단하게 설명하면 다음과 같다:

### 데이터베이스 연결 함수
- `connectDB`: 데이터베이스에 연결하고 연결 객체를 반환한다.
- `disconnectDB`: 데이터베이스 연결을 닫는다.

### 주소 찾기 함수
- `find_address`: 데이터베이스에서 주어진 도메인 주소에 대한 IP 주소를 조회한다. IP 주소가 없으면 오류 메시지를 반환한다.

### 클라이언트 처리 함수
- `handle_client`: 클라이언트의 요청을 처리하고 결과를 클라이언트에게 반환한다. 클라이언트가 "exit"를 입력하면 연결을 종료한다.

### 서버 프로그램 함수
- `server_program`: 서버 소켓을 생성하고 클라이언트의 연결을 대기하며, 클라이언트가 연결되면 `handle_client` 함수를 호출하여 처리한다.

### 요약
1. 서버는 클라이언트로부터 도메인 주소를 수신한다.
2. 데이터베이스에서 도메인 주소에 대한 IP 주소를 조회한다.
3. IP 주소가 존재하면 클라이언트에게 반환한다.
4. IP 주소가 존재하지 않으면 오류 메시지를 반환한다.
5. 클라이언트가 "exit"를 입력하면 연결을 종료한다.

이 프로그램은 주로 클라이언트의 도메인 주소 요청을 처리하여 상위 DNS 서버 역할을 한다.

<br>

### 데이터베이스

![image](https://github.com/Bogamie/bogamie.github.io/assets/162293185/60c925d2-8bd2-491a-b453-b6c32478ba40)

#### 데이터베이스 구조

- domain: 도메인 이름을 저장하는 필드이다. 예를 들어, example.com.
- ip: 해당 도메인 이름에 대한 IP 주소를 저장하는 필드이다. 예를 들어, 93.184.216.34.

### 실행 화면

#### 로컬 DNS 서버에 주소가 존재하는 경우

![image](https://github.com/Bogamie/bogamie.github.io/assets/162293185/ab2c4d17-dd8d-4f33-a595-27edc468258f)

로컬 DNS에 찾고자 하는 주소가 존재하면 로컬 DNS에 저장되어 있는 데이터베이스에 접근하여 ip 주소를 얻고 반환한다. 

#### 로컬 DNS 서버에 주소가 존재하지 않는 경우

![image](https://github.com/Bogamie/bogamie.github.io/assets/162293185/96ce6d8c-5d28-449d-8e1e-2c71470cf66a)

로컬 DNS의 데이터베이스에 도메인 주소가 없다면 상위 DNS와 통신하여 ip 주소를 얻는다. 그 후 로컬 DNS는 ip 주소를 얻고 자신의 데이터베이스에 추가한다. 아래는 webapp.site 도메인 주소가 추가된 모습이다.

![image](https://github.com/Bogamie/bogamie.github.io/assets/162293185/23db8ad5-d522-4a0c-a488-57e2239a0cae){: height="50%" width="50%"}

#### 상위, 로컬 DNS 서버에 존재하지 않는 경우

![image](https://github.com/Bogamie/bogamie.github.io/assets/162293185/26957de5-984e-48a4-b669-17fa381f8599)

두 DNS 서버 모두 도메인 주소가 없다면 에러를 반환한다.